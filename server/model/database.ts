import redis = require("redis");
import rp = require("request-promise");

import admin from "./firebase";
import {
	AutoCompleteData,
	Course,
	CourseQuery,
	UserInfo,
	APIRequestDoc,
} from "./types";
import { courseToString } from "../scripts";
import { firestore } from "firebase-admin";

// Extract the environment variables that are needed.
const redis_url = process.env["REDIS_URL"];
const worker_url = process.env["worker_url"];

// Connect to the Redis client.
const client = redis.createClient({
	url: redis_url || "redis://127.0.0.1:6379/0",
});

client.on("connect", function () {
	console.log("redis connected.");
});

// All methods that interact with the database are implemented here.
abstract class Database {
	// private variable declaration
	private static db = admin.firestore();
	private static coursesCollection = Database.db.collection("courses");
	private static courseDetailsCollection =
		Database.db.collection("courseDetails");
	private static usersCollection = Database.db.collection("users");
	private static apiRequests = Database.db.collection("apiRequests");
	private static accessTokens = Database.db.collection("accessTokens");
	private static paymentOrders = Database.db.collection("payments");

	// public API

	/**
	 * Creates an application for API access and associates it to the given uid/user.
	 * @param uid unique id of the user
	 * @param requestData data required for submitting an application
	 */
	public static async createAPITokenRequest(
		uid: string,
		requestData: { name: string; purpose: string }
	): Promise<APIRequestDoc> {
		// Get user with associated uid.
		const user: UserInfo = await this.getUser(uid);

		// Retrieve document from apiRequests collection indexed by uid.
		const docRef = this.apiRequests.doc(uid);
		const doc = await docRef.get();

		// If document does not exist, create an entry.
		if (!doc.exists) {
			const docData: APIRequestDoc = {
				uid,
				email: user.email,
				status: "pending",
				...requestData,
				date: admin.firestore.Timestamp.now(),
			};
			await docRef.set(docData);
			return docData;
		}

		// Return application status.
		return <APIRequestDoc>doc.data();
	}

	/**
	 * Method to get all applications for api access
	 */
	public static async getAllApiTokenRequests(): Promise<
		Array<APIRequestDoc>
	> {
		// Fetch all documents within apiRequests collection.
		const snapshot = await this.apiRequests.get();

		return snapshot.docs.map((doc) => {
			const data = <APIRequestDoc>doc.data();

			data.date = data.date
				? (data.date as firestore.Timestamp).toDate()
				: null;
			// Old applications might not have the uid property attached to them
			// as it's a relatively new addition.
			data.uid = data.uid ?? doc.id;
			return data;
		});
	}

	/**
	 * Returns the status of the application for API access.
	 * @param uid unique id of the user
	 */
	public static async getAPITokenRequestStatus(uid: string): Promise<object> {
		// create docRef and fetch it
		const docRef = this.apiRequests.doc(uid);
		const doc = await docRef.get();

		// return the status if it exists, null status otherwise
		return doc.exists ? doc.data() : { status: null };
	}

	/**
	 * Approves the application for API access, creates a new accessToken, and
	 * associates the token with user.
	 * @param uid unique id of the user
	 * @param token the API access token (simple uuid for now) generated by the server
	 */
	public static async approveTokenRequest(
		uid: string,
		accessToken: string,
		adminUID: string
	) {
		// Create docRef for the api request.
		const docRef = this.apiRequests.doc(uid);

		// Update the status of the request to 'approved'.
		await docRef.update({
			status: "approved",
			accessToken,
			approvedBy: adminUID,
		});

		// Create a new entry in AccessTokens collection and link the application filled for this token.
		await this.accessTokens
			.doc(accessToken)
			.set({ accessToken, requestRef: docRef });
	}

	/**
	 * Verify access token for `/api` endpoint.
	 * @param accessToken the API access token (simple uuid for now)
	 */
	public static async verifyAccessToken(accessToken: string): Promise<void> {
		// Create docRef for the api request
		const docRef = this.accessTokens.doc(accessToken);

		// Fetch document data
		const data = await docRef.get();

		if (!data.exists) throw Error("Invalid access token!");
		return;
	}

	public static async paymentSuccess(uid: string) {
		await this.usersCollection.doc(uid).update({
			numNotifications: admin.firestore.FieldValue.increment(5),
		});
	}

	public static async createPayment(uid: string) {
		await this.paymentOrders.add({
			uid,
			timestamp: admin.firestore.FieldValue.serverTimestamp(),
		});
	}

	/**
	 * Subscribes a user to the section passed as a parameter.
	 * @param uid unique id of the user
	 * @param course data identifying the course to fetch
	 */
	public static async subscribeUserToSection(
		uid: string,
		{ subject, course, year, semester, section }: CourseQuery
	): Promise<string[]> {
		// Reference the user's document.
		const docRef = this.usersCollection.doc(uid);

		// Stringify (string representation) course & section.
		const sectionId = [subject, course, year, semester, section]
			.join("_")
			.toUpperCase();

		try {
			// Retrieve user profile to verify if phoneNumber is valid
			const updatedUser = await docRef.get();
			const { subscribedSections, phoneNumber, numNotifications } =
				updatedUser.data();

			if (!phoneNumber) {
				throw new Error(
					"Invalid number! Cannot subscribe user to section."
				);
			}

			// race condition (lol)
			if (numNotifications <= 0) {
				throw new Error(
					"You do not have any notifications remaining! Please proceed to checkout."
				);
			}

			// Add the section to the user's profile.
			await docRef.update({
				subscribedSections:
					admin.firestore.FieldValue.arrayUnion(sectionId),
				numNotifications: admin.firestore.FieldValue.increment(-1),
			});

			// Add id of section to the Redis HashSet, allowing Heroku worker
			// to read and notify all subscribed users.
			client.sadd("subscribedSections", sectionId);

			const updatedSubscribedSections = new Set([
				...subscribedSections,
				sectionId,
			]);

			return [...updatedSubscribedSections.values()];
		} catch (err) {
			throw err;
		}
	}

	/**
	 * Returns a list of auto-suggested courses given a string (i.e. autocomplete feature)
	 * @param str user input to match against potential course codes (e.g. COMP2, MATH24)
	 */
	public static async autocomplete(str: string): Promise<AutoCompleteData[]> {
		try {
			// Naive autocomplete feature.
			const query = await this.coursesCollection
				.where("courseCode", ">=", str)
				.where("courseCode", "<=", str.padEnd(9, "Z"))
				.limit(5)
				.get();

			return Promise.resolve(
				query.docs.map((doc) => <AutoCompleteData>doc.data())
			);
		} catch (err) {
			throw { error: err.message || err.toString() };
		}
	}

	/**
	 * Method to retrieve the profile of a given user.
	 * @param uid unique id of the user
	 */
	public static async getUser(uid: string): Promise<UserInfo> {
		// get reference to document of uid
		const docRef = this.usersCollection.doc(uid);
		try {
			// fetch the reference/doc
			const userDoc = await docRef.get();
			return userDoc.exists ? <UserInfo>userDoc.data() : null;
		} catch (err) {
			throw err;
		}
	}

	/**
	 * Method to handle user login
	 * –– returns the user if they exist, otherwise creates a new profile for the user ––
	 * @param uid unique user id
	 */
	public static async login(uid: string): Promise<UserInfo> {
		try {
			let user: UserInfo = await this.getUser(uid);
			// If the user does not exist, create it.
			if (!user) {
				// Retrieves data from the sign-in provider (fb or google)
				// and defaults the remaining values to empty strings.
				const {
					displayName = "",
					email = "",
					photoURL = "",
					phoneNumber = "",
				}: admin.auth.UserRecord = await admin.auth().getUser(uid);

				user = {
					uid,
					displayName,
					email,
					photoURL,
					phoneNumber,
					subscribedSections: [],
					numNotifications: 0,
				};

				// Save new profile to Users collections.
				await this.usersCollection.doc(uid).set(user);
			}

			return user;
		} catch (err) {
			throw err;
		}
	}

	/**
	 * Queries course information either from cache or real-time.
	 * @param queryParams data identifying the course to fetch
	 * @param forceRefresh boolean flag to force real-time data refresh
	 */
	public static async queryCourse(
		queryParams: CourseQuery,
		forceRefresh: boolean = false
	): Promise<Course> {
		// If forceRefresh flag is true, fetch live details and return data.
		if (forceRefresh) return this.addCourseDetails(queryParams);
		else {
			// Attempt to read course from db (cached data). If not present
			// or outdated (> 5 min), query live data from McGill.
			const course: Course = await this.getCourseFromDB(queryParams);

			return course ?? (await this.addCourseDetails(queryParams));
		}
	}

	/**
	 * Unsubscribes a user from notifications regarding this course.
	 * @param uid the unique user id
	 * @param course data identifying the course/section to unsubscribe from
	 */
	public static async unsubscribeUserFromSection(
		uid: string,
		{ subject, course, year, semester, section }: CourseQuery
	): Promise<string[]> {
		// Reference user's document.
		const docRef = this.usersCollection.doc(uid);

		// Stringify section/course.
		const sectionId = [subject, course, year, semester, section]
			.join("_")
			.toUpperCase();

		try {
			// Remove the section from user's subscribedSections.
			await docRef.update({
				subscribedSections:
					admin.firestore.FieldValue.arrayRemove(sectionId),
				numNotifications: admin.firestore.FieldValue.increment(1),
			});

			const updatedUser = await docRef.get();
			const updatedSubscribedSections: string[] =
				updatedUser.data().subscribedSections;

			return updatedSubscribedSections;
		} catch (err) {
			throw { error: err.message || err.toString() };
		}
	}

	/**
	 * Update a user's profile.
	 * @param uid uid of user
	 * @param data user data to update
	 */
	public static async updateUser(
		uid: string,
		data: UserInfo
	): Promise<UserInfo> {
		// Reference user's document.
		const docRef = this.usersCollection.doc(uid);
		try {
			// Update user profile and return newly
			// updated document.
			await docRef.update(data);

			const updatedData = await docRef.get();
			return <UserInfo>updatedData.data();
		} catch (err) {
			throw { error: err.message || err.toString() };
		}
	}

	// private API
	/**
	 * Retrieves course from firestore db, returns null if not present or outdated (> 5 min)
	 * @param courseQuery data identifying the course/section to fetch
	 */
	private static async getCourseFromDB(
		courseQuery: CourseQuery
	): Promise<Course> {
		// Stringify course/section.
		const key = courseToString(courseQuery);
		try {
			// Fetch document/course from DB.
			const doc = await this.courseDetailsCollection.doc(key).get();

			// `needsRenew` is set to true if the document does not exist
			// or is outdated (has been > 5 min since last write).
			const needsRenew =
				!doc.exists ||
				new Date().getTime() -
					(
						doc.data().updated as admin.firestore.Timestamp
					).toMillis() >
					300000;

			return needsRenew
				? null
				: <Course>{ ...doc.data(), updated: undefined };
		} catch (err) {
			throw { error: err.message || err.toString() };
		}
	}

	/**
	 * Retrieves the live details (not cached) for a given course and adds it to the database.
	 * @param {CourseQuery} courseQuery data identifying the course/section to fetch
	 */
	private static async addCourseDetails({
		course,
		subject,
		semester,
		year,
	}: CourseQuery): Promise<Course> {
		const key: string = courseToString({ course, subject, year, semester });

		// send parameters to uppercase
		course = course.toUpperCase();
		subject = subject.toUpperCase();
		semester = semester.toUpperCase();
		year = year.toUpperCase();

		return rp({
			uri: `${worker_url}/${subject}/${course}/${year}/${semester}`,
			json: true,
		})
			.then((course) => {
				this.courseDetailsCollection.doc(key).set({
					...course,
					updated: admin.firestore.FieldValue.serverTimestamp(),
				});
				return course;
			})
			.catch((err) => {
				return err;
			});
	}
}

export default Database;
